#include<stdio.h>
#include<math.h>


// Bohr radius in SI units
double a0_SI = 5.2917721067e-11;
// Bohr radius in atomic units
double a0 = 1.0;

double L_Z_A(double x);
double L_O_A(int alpha, double x);
double L_KP1_A(int k, int alpha, double Lk, double Lkm1, double x);
double Laguerre(int k, int alpha, double x);
double L_2_A(int k, int alpha, double x);
double L_3_A(int k, int alpha, double x);
int main() {

  double pi = 3.14159265359;
  double Z = 1;  // Nuclear charge of hydrogen in atomic units
  double a0 = 1;  // Bohr radius in atomic units
  double h = 1;  // Planck's constant in atomic units
  double m = 1;  // mass of electron in atomic units
  int i, n, l;

  double value, x, dvalue;
  for (i=0; i<100; i++) {
    x = -2 + 0.1*i; 
    value = Laguerre( 3, 2, x);
    dvalue = L_3_A(3, 2, x);
    printf("  %f  %f  %f\n",x,value, dvalue);
  }

  // h is independent variable (radius)
  // j is dependent variable (radial function)
  // double h, j;
  // double dh = R/100.;
  // n = 1;
  // l = 0;
  // for (i = 0; i<=100; i++) {
  // h = 1e-6 + dh*i;
  // j = (2./sqrt(R))*(1/h)*cos((pi/2.)*(2*n+l+2)*(h/R)-(l+1));
  // printf("  %12.8f  %12.8f\n",h,j);
  //}
  // return 0;
  // }
  // ~                                                                                                                
  // ~      
  return 0;
 }

double L_Z_A(double x) {

  return 1.;

}

double L_O_A(int alpha, double x) {
  double term;
  term = 1. + alpha - x;
  return term;

}

double L_KP1_A(int kp1, int alpha, double Lk, double Lkm1, double x) {
  int k = kp1-1;
  double num, denom;
  num = (2*k+1+alpha-x)*Lk-(k+alpha)*Lkm1;
  denom = k+1;
  return num/denom;

}

// k is the subscript and alpha is the superscript
// in the associated Laguere polynomial
// L_k^alpha ( x ) 
double Laguerre(int k, int alpha, double x) {

  double Lkp1, Lk, Lkm1;
  int tk;

  if (k==0) return L_Z_A( x );
  else if (k==1) return L_O_A(alpha, x);
  else if (k==2) {
     Lk = L_O_A(alpha, x);
     Lkm1 = L_Z_A(x);
     L_KP1_A( k, alpha, Lk, Lkm1, x);
  }

  else {

    tk = 1;
    Lk = L_O_A(alpha, x);
    Lkm1 = L_Z_A( x );

    while (tk<k) {
 
      Lkp1 = L_KP1_A( tk+1, alpha, Lk, Lkm1, x);
      tk++;
      Lkm1 = Lk;
      Lk = Lkp1;

    }
    return Lkp1;  

  }
}
double L_2_A(int k, int alpha, double x) {

  return (x*x/2 - (alpha+2)*x + (alpha + 2)*(alpha + 1)/2);
}

double L_3_A(int k, int alpha, double x) {

  return ((-x*x*x)/6 + (alpha + 3)*x*x/2 - (alpha+2)*(alpha+3)*x/2 + (alpha+1)*(alpha+2)*(alpha+3)/6);

}
